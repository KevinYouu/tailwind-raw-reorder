# 正则表达式修复总结

## 问题

`package.json` 中的正则表达式无法正确处理嵌套的模板字符串，导致如下代码被错误格式化：

**原始代码：**
```jsx
className={`whitespace-pre-wrap text-sm text-gray-600 ${
  !isExpanded ? `line-clamp-${maxLines}` : ''
}`}
```

**错误格式化为：**
```jsx
className={`whitespace-pre-wrap text-sm text-gray-600 ${
  !isExpanded ? }`line-clamp-${maxLines}` : ''
}`}
```

## 根本原因

旧的正则表达式使用了 `[^`]*` 模式：

```javascript
"`([^`]*(?:\\$\\{[^}]*\\}[^`]*)*)`"
```

- `[^`]*` 表示"匹配任何不是反引号的字符"
- 遇到嵌套模板字符串时，在第一个内层反引号处就停止匹配
- 只捕获了部分内容：`` `whitespace-pre-wrap ... ? ` ``

## 解决方案

采用**第三种方案**：使用非贪婪匹配 + 前瞻断言

### 新的正则表达式

```javascript
// 第一层：匹配整个 className={`...`}
"(?:class(?:Name)?|tw)\\s*=\\s*\\{\\s*(`[\\s\\S]*?`(?=\\s*\\}))"

// 第二层：提取模板字符串内容
"`([\\s\\S]*)`"
```

### 工作原理

1. **`[\\s\\S]*?`**：非贪婪匹配任何字符（包括换行）
   - `\s` 匹配空白字符
   - `\S` 匹配非空白字符
   - `*?` 非贪婪模式，尽可能少匹配

2. **`(?=\\s*\\})`**：前瞻断言，确保后面跟着 `}`
   - 这确保我们匹配到正确的结束反引号
   - 不消耗字符，只是检查

3. **优势**：
   - 可以正确处理嵌套的反引号
   - 可以处理多行模板字符串
   - 逻辑简单，不依赖复杂的递归模式

## 修改内容

在 `package.json` 中更新了三个语言配置：

### 1. javascriptreact
```json
"javascriptreact": [
  [
    "(?:class(?:Name)?|tw)\\s*=\\s*\\{\\s*(`[\\s\\S]*?`(?=\\s*\\}))",
    "`([\\s\\S]*)`"
  ],
  [
    "(?:class(?:Name)?|tw)\\s*=\\s*\\{?(([\"'])(?:(?:[^{}<>](?!\\2))|\\\\\\2)+[^{}<>]\\2)",
    "[\"']([^\"']+)[\"']"
  ]
]
```

### 2. typescript
```json
"typescript": [
  [
    "(?:class(?:Name)?|tw)\\s*=\\s*\\{\\s*(`[\\s\\S]*?`(?=\\s*\\}))",
    "`([\\s\\S]*)`"
  ],
  [
    "(?:class(?:Name)?|tw)\\s*=\\s*\\{?(([\"'])(?:(?:[^{}<>](?!\\2))|\\\\\\2)+[^{}<>]\\2)",
    "[\"']([^\"']+)[\"']"
  ]
]
```

### 3. typescriptreact
```json
"typescriptreact": [
  [
    "(?:class(?:Name)?|tw)\\s*=\\s*\\{\\s*(`[\\s\\S]*?`(?=\\s*\\}))",
    "`([\\s\\S]*)`"
  ],
  [
    "(?:class(?:Name)?|tw)\\s*=\\s*\\{?(([\"'])(?:(?:[^{}<>](?!\\2))|\\\\\\2)+[^{}<>]\\2)",
    "[\"']([^\"']+)[\"']"
  ]
]
```

## 测试验证

创建了全面的测试用例 `test/regex-issue.spec.ts`：

1. **测试嵌套模板字符串**
   - 验证正则能正确捕获完整内容
   - 验证排序后结构保持不变

2. **测试改进的正则模式**
   - 验证第一层匹配包含完整的嵌套模板
   - 验证第二层提取正确的内容

3. **对比旧正则的问题**
   - 展示旧正则如何在嵌套时失败

### 测试结果

✅ 所有 39 个测试用例通过
✅ 没有破坏现有功能
✅ 正确处理嵌套模板字符串

## 影响范围

- ✅ 现在可以正确处理嵌套的模板字符串
- ✅ 支持多行模板字符串
- ✅ 保持向后兼容
- ✅ 所有现有测试继续通过

## 示例

### 修复前
```jsx
// 输入
className={`text-sm ${!isExpanded ? `line-clamp-${maxLines}` : ''}`}

// 错误输出（反引号位置错误）
className={`text-sm ${!isExpanded ? }`line-clamp-${maxLines}` : ''}`}
```

### 修复后
```jsx
// 输入
className={`text-sm ${!isExpanded ? `line-clamp-${maxLines}` : ''}`}

// 正确输出（结构保持不变，类名被正确排序）
className={`text-sm ${!isExpanded ? `line-clamp-${maxLines}` : ''}`}
```

## 未来改进

如果需要处理更复杂的情况（如三层或更多层嵌套），可以考虑：

1. 使用 AST 解析器（如 Babel parser）
2. 实现自定义的字符级解析器
3. 使用递归正则（某些正则引擎支持）

但对于绝大多数实际使用场景，当前的解决方案已经足够。
